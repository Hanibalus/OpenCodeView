<pre>
#include&lt;iostream&gt;
using namespace std;

typedef struct tree_node {
   int value;
   struct tree_node *left, *right;
}node;

// create a new node
node *getNewNode(int value) {
   node *new_node = new node;
   new_node-&gt;value = value;
   new_node-&gt;left = NULL;
   new_node-&gt;right = NULL;
   return new_node;
}

// create the tree
node *createTree() {
   node *root = getNewNode(31);
   root-&gt;left = getNewNode(16);
   root-&gt;right = getNewNode(45);
   root-&gt;left-&gt;left = getNewNode(7);
   root-&gt;left-&gt;right = getNewNode(24);
   root-&gt;left-&gt;right-&gt;left = getNewNode(19);
   root-&gt;left-&gt;right-&gt;right = getNewNode(29);
   return root;
}

// Inorder traversal of a tree
void inorderTraversal(node *ptr) {
   if(ptr == NULL)
      return;
   else {
      inorderTraversal(ptr-&gt;left);
      cout&lt;&lt;ptr-&gt;value&lt;&lt;"\t";
      inorderTraversal(ptr-&gt;right);
   }
}

// create mirror tree
node* mirror(node* root) {
   node* m_root = NULL;
   if(!root) return NULL;
   m_root = getNewNode(root-&gt;value);
   m_root-&gt;left = mirror(root-&gt;right);
   m_root-&gt;right = mirror(root-&gt;left);
   return m_root;
}

// main
int main() {
   node *root = createTree();
   cout&lt;&lt;"\n Inorder traversal before conversion ";
   inorderTraversal(root);
   node *m_root = mirror(root);
   cout&lt;&lt;"\n Inorder traversal after conversion ";
   inorderTraversal(m_root);
   cout&lt;&lt;endl;
   return 0;
}
</pre>
