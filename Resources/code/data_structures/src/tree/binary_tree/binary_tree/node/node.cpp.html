<pre>
/*
 Part of Cosmos by OpenGenus Foundation

 tree node synopsis

// for normal binary tree
template&lt;typename _Type&gt;
class TreeNode
{
protected:
    using SPNodeType = std::shared_ptr&lt;TreeNode&gt;;
    using ValueType = _Type;

public:
    TreeNode(ValueType v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :value_(v), left_(l), right_(r) {}

    ValueType value() {
        return value_;
    }

    void value(ValueType v) {
        value_ = v;
    }

    SPNodeType left() {
        return left_;
    }

    void left(SPNodeType l) {
        left_ = l;
    }

    SPNodeType right() {
        return right_;
    }

    void right(SPNodeType r) {
        right_ = r;
    }

private:
    ValueType value_;
    SPNodeType left_;
    SPNodeType right_;
};

// for derivative binary tree (e.g., avl tree, splay tree)
template&lt;typename _Type, class _Derivative&gt;
class __BaseTreeNode
{
protected:
    using SPNodeType = std::shared_ptr&lt;_Derivative&gt;;
    using ValueType = _Type;

public:
    __BaseTreeNode(ValueType v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :value_(v), left_(l), right_(r) {}

    ValueType value() {
        return value_;
    }

    void value(ValueType v) {
        value_ = v;
    }

    SPNodeType left() {
        return left_;
    }

    void left(SPNodeType l) {
        left_ = l;
    }

    SPNodeType right() {
        return right_;
    }

    void right(SPNodeType r) {
        right_ = r;
    }

private:
    ValueType value_;
    SPNodeType left_;
    SPNodeType right_;
};

template&lt;typename _Type&gt;
class DerivativeTreeNode :public __BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;
{
private:
    using BaseNode = __BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;;
    using SPNodeType = typename BaseNode::SPNodeType;
    using ValueType = typename BaseNode::ValueType;

public:
    DerivativeTreeNode(_Type v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :__BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;(v, l, r) {}
};
 */

#include &lt;memory&gt;

#ifndef TREE_NODE_POLICY
#define TREE_NODE_POLICY

template&lt;typename _Type&gt;
class TreeNode
{
protected:
    using SPNodeType = std::shared_ptr&lt;TreeNode&gt;;
    using ValueType = _Type;

public:
    TreeNode(ValueType v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :value_(v), left_(l), right_(r) {}

    ValueType value() {
        return value_;
    }

    void value(ValueType v) {
        value_ = v;
    }

    SPNodeType left() {
        return left_;
    }

    void left(SPNodeType l) {
        left_ = l;
    }

    SPNodeType right() {
        return right_;
    }

    void right(SPNodeType r) {
        right_ = r;
    }

private:
    ValueType value_;
    SPNodeType left_;
    SPNodeType right_;
};

template&lt;typename _Type, class _Derivative&gt;
class __BaseTreeNode
{
protected:
    using SPNodeType = std::shared_ptr&lt;_Derivative&gt;;
    using ValueType = _Type;

public:
    __BaseTreeNode(ValueType v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :value_(v), left_(l), right_(r) {}

    ValueType value() {
        return value_;
    }

    void value(ValueType v) {
        value_ = v;
    }

    SPNodeType left() {
        return left_;
    }

    void left(SPNodeType l) {
        left_ = l;
    }

    SPNodeType right() {
        return right_;
    }

    void right(SPNodeType r) {
        right_ = r;
    }

private:
    ValueType value_;
    SPNodeType left_;
    SPNodeType right_;
};

template&lt;typename _Type&gt;
class DerivativeTreeNode :public __BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;
{
private:
    using BaseNode = __BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;;
    using SPNodeType = typename BaseNode::SPNodeType;
    using ValueType = typename BaseNode::ValueType;

public:
    DerivativeTreeNode(_Type v, SPNodeType l = nullptr, SPNodeType r = nullptr)
        :__BaseTreeNode&lt;_Type, DerivativeTreeNode&lt;_Type&gt;&gt;(v, l, r) {}
};

#endif // TREE_NODE_POLICY
</pre>
