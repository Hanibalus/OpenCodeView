<pre>
/*
Data Structures : Finding Diameter of a binary tree

Description : Diameter of tree is defined as the longest path or route between any two nodes in a tree.
              This path may or may not be through the root. The below algorithm computes the height of 
              the tree and uses it recursivley in the calculation of diameter of the specified tree.

A massive collaborative effort by OpenGenus Foundation
*/

#include&lt;iostream&gt;
using namespace std;

// get the max of two no.s
int max(int a, int b) {
   return ((a &gt; b) ? a : b);
}

typedef struct node {
   int value;
   struct node *left, *right;
}node;

// create a new node
node *getNewNode(int value) {
   node *new_node = new node;
   new_node-&gt;value = value;
   new_node-&gt;left = NULL;
   new_node-&gt;right = NULL;
   return new_node;
}

// compute height of the tree
int getHeight(node *root) {
   if (root == NULL)
      return 0;

      // find the height of each subtree
      int lh = getHeight(root-&gt;left);
      int rh = getHeight(root-&gt;right);

      return 1 + max(lh,rh);
}

// compute tree diameter recursively 
int getDiameter(node *root) {
   if (root == NULL)
      return 0;

   // get height of each subtree
   int lh = getHeight(root-&gt;left);
   int rh = getHeight(root-&gt;right);

   // compute diameters of each subtree
   int ld = getDiameter(root-&gt;left);
   int rd = getDiameter(root-&gt;right);

   return max(lh+rh+1,max(ld,rd));
}

// create the tree
node *createTree() {
   node *root = getNewNode(31);
   root-&gt;left = getNewNode(16);
   root-&gt;right = getNewNode(52);
   root-&gt;left-&gt;left = getNewNode(7);
   root-&gt;left-&gt;right = getNewNode(24);
   root-&gt;left-&gt;right-&gt;left = getNewNode(19);
   root-&gt;left-&gt;right-&gt;right = getNewNode(29);
   return root;
}

// main
int main() {
   node *root = createTree();
   cout&lt;&lt;"\nDiameter of the tree is "&lt;&lt;getDiameter(root);
   cout&lt;&lt;endl;
   return 0;
}
</pre>
